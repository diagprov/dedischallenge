package schnorrgs

/* This file implements Schnorr-multi signatures
   based on the schnorr.go file of this library.
*/

import (
	"bytes"
	"github.com/dedis/kyber"
	"io"
)

// Represents a private commitment generated by a given server
type SchnorrMSCommitment struct {
	v kyber.Scalar
	T kyber.Point
}

// Encodes a private commitment as a binary string.
func (sc SchnorrMSCommitment) MarshalBinary() ([]byte, error) {
	var result bytes.Buffer

	b, err := sc.v.MarshalBinary()
	if err != nil {
		return nil, err
	}
	result.Write(b)

	b, err = sc.T.MarshalBinary()
	if err != nil {
		return nil, err
	}
	result.Write(b)

	return result.Bytes(), nil
}

// Marshals to an io.Writer interface, in case we want that.
func (sc SchnorrMSCommitment) MarshalTo(w io.Writer) {
	sc.v.MarshalTo(w)
	sc.T.MarshalTo(w)
}

// Opposite of marshallbinary; recovers a private commitment
// from a binary string. Requires a known suite to decode correctly.
// Ignores excess binary (can be used on larger than necessary buffers).
func (sc SchnorrMSCommitment) UnmarshalBinary(suite CryptoSuite, b []byte) error {
	v := suite.Scalar()
	T := suite.Point()

	err := v.UnmarshalBinary(b[:sc.v.MarshalSize()])
	if err != nil {
		return err
	}
	err = T.UnmarshalBinary(b[sc.v.MarshalSize():sc.T.MarshalSize()])
	if err != nil {
		return err
	}
	sc.T = T
	sc.v = v
	return nil
}

// Returns the public component of a commitment (essentially a point)
func (msc SchnorrMSCommitment) GetPublicCommitment() SchnorrMSPublicCommitment {
	return SchnorrMSPublicCommitment{T: msc.T}
}

// Represents the public commitment made by the server to the client.
type SchnorrMSPublicCommitment struct {
	T kyber.Point
}

// Converts the public commitment to a binary string
func (pc SchnorrMSPublicCommitment) MarshalBinary() ([]byte, error) {
	var result bytes.Buffer

	b, err := pc.T.MarshalBinary()
	if err != nil {
		return nil, err
	}
	result.Write(b)

	return result.Bytes(), nil
}

// Marshals the public commitment to an arbitary writer
func (pc SchnorrMSPublicCommitment) MarshalTo(w io.Writer) {
	pc.T.MarshalTo(w)
}

// Unmarshals the public commitment from a binary string.
func (pc *SchnorrMSPublicCommitment) UnmarshalBinary(suite CryptoSuite, b []byte) error {
	var T = suite.Point()
	var sz = suite.Point().MarshalSize()
	err := T.UnmarshalBinary(b[0:sz])
	if err != nil {
		return err
	}
	pc.T = T
	return nil
}

// Generates a commitment from a random stream provided in the cryptosuite.
func SchnorrMSGenerateCommitment(suite CryptoSuite) SchnorrMSCommitment {

	v := suite.Scalar().Pick(suite.RandomStream())
	T := suite.Point().Mul(v, nil)

	return SchnorrMSCommitment{v: v, T: T}
}

// Generates an aggregate commitment from provided public commitments
func SchnorrMSAggregateCommitment(suite CryptoSuite,
	commitments []SchnorrMSPublicCommitment) SchnorrMSPublicCommitment {

	aggCommitment := suite.Point().Null()

	for _, commitment := range commitments {
		aggCommitment = suite.Point().Add(aggCommitment, commitment.T)
	}

	return SchnorrMSPublicCommitment{T: aggCommitment}
}

// Generates a shared public key from provided public keys. The result is
// "just another" public key and not in any way a special type.
func SchnorrMSComputeSharedPublicKey(suite CryptoSuite,
	pubkeys []SchnorrPublicKV) SchnorrPublicKV {

	sharedpubkey := suite.Point().Null()

	for _, key := range pubkeys {
		sharedpubkey = suite.Point().Add(sharedpubkey, key.pP)
	}

	return SchnorrPublicKV{suite: "BlakeSHA256Ed25519", pP: sharedpubkey}
}

// Computes the collective challenge given an aggregate commitment and
// the message we wish to challenge with.
func SchnorrMSComputeCollectiveChallenge(suite CryptoSuite,
	aggcommit SchnorrMSPublicCommitment, msg []byte) (kyber.Scalar, error) {
	return SchnorrHashPointsMsgToScalar(suite, aggcommit.T, msg)
}

// Computes the server "response" component using its private key,
// private commitment and collective challenge c
func SchnorrMSComputeResponse(suite CryptoSuite,
	c kyber.Scalar, privkey SchnorrSecretKV,
	privcommit SchnorrMSCommitment) kyber.Scalar {

	r := suite.Scalar().Zero()
	r = r.Mul(c, privkey.s)
	r = r.Sub(privcommit.v, r)

	return r
}

// Computes the combined response from all server responses. This can be
// combined with the collective challenge to form a signature.
func SchnorrMSComputeCombinedResponse(suite CryptoSuite,
	responses []kyber.Scalar) kyber.Scalar {

	tr := suite.Scalar().Zero()

	for _, r := range responses {
		tr = suite.Scalar().Add(tr, r)
	}

	return tr
}

// Helper function to build a signature type from the combined responses and
// combined challenge.
func SchnorrMSCreateSignature(suite CryptoSuite, c kyber.Scalar,
	r kyber.Scalar) SchnorrSignature {

	return SchnorrSignature{S: r, E: c}
}
